class Solution {
public:
    unordered_map<int, int> infected;
    
    pair<bool, int> dfs(int node, vector<int>& vis, vector<vector<int>>& graph){
        vis[node] = 1;
        if(infected[node]) return {false, 0};
        int ct = 1;
        bool f = 1;
        for(int i = 0; i < graph.size(); i++){
            if(!vis[i] && graph[node][i]){
                auto t = dfs(i, vis, graph);
                if(t.first) ct += t.second;
                else f = 0;
            }
        }
        return {f, ct};
    }
    
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        //To get shortest index as answer while traversing
        sort(initial.begin(), initial.end());
        for(int i = 0; i < initial.size(); i++) infected[initial[i]]++;
        
        int mx = -1, ans = -1;
        for(int i = 0; i < initial.size(); i++){
            vector<int> vis(n, 0);
            int node = initial[i];
            vis[node] = 1;
            int x = 0;
            for(int i = 0; i < n; i++){
                if(!vis[i] && graph[node][i]){
                    auto t = dfs(i, vis, graph);
                    //If branch doesn't have infected node
                    if(t.first) x += t.second;
                }
            }
            if(x > mx){
                mx = x;
                ans = node;
            }
        }
        return ans;
    }
};

